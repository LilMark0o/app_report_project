================================================================================
SCREENSHOT REQUIREMENTS - RustDesk Performance Analysis
================================================================================
Fecha: 2025-11-21
Total screenshots necesarios: 13
================================================================================

RESUMEN EJECUTIVO:
El reporte latex_app_report_final.ltx está completo con análisis teórico (30/30
puntos). Para validación empírica, se necesitan 13 screenshots de profiling
tools. Este documento describe EXACTAMENTE qué capturar y cómo debe verse
cada screenshot.

================================================================================
1. GPU RENDERING TIMELINE (1 screenshot)
================================================================================

HERRAMIENTA:
- Android: Android Studio Profiler → GPU
- iOS: Xcode Instruments → Core Animation

CÓMO CAPTURAR:
1. Abrir profiler
2. Iniciar sesión de profiling
3. Conectarse remotamente y mantener sesión activa 60 segundos
4. Capturar screenshot del timeline de frame times

QUÉ DEBE MOSTRAR EL SCREENSHOT:
- Eje X: Tiempo (60 segundos)
- Eje Y: Frame time en milisegundos
- Barras VERDES: Frames <16ms (60fps) o <33ms (30fps) - BUENO
- Barras AMARILLAS/ROJAS: Frames que exceden budget - JANK
- Target line: Línea horizontal en 16ms (60fps) o 33ms (30fps)

RESULTADO ESPERADO (basado en código):
- Mayoría de barras verdes durante uso normal
- Picos amarillos ocasionales durante zoom (cuando filtering aumenta)
- Validar claim: Adaptive filtering ahorra 15-20ms per frame

UBICACIÓN EN REPORTE: Línea 2373-2388 del latex_app_report_final.ltx

================================================================================
2. OVERDRAW ANALYSIS (4 screenshots)
================================================================================

HERRAMIENTA:
- Android: Developer Options → Debug GPU Overdraw → "Show overdraw areas"

CÓDIGO DE COLORES:
- AZUL = 1x overdraw (óptimo)
- VERDE = 2x overdraw (aceptable)
- ROSA/PINK = 3x overdraw (precaución)
- ROJO = 4x+ overdraw (problema)

CÓMO CAPTURAR:
1. Activar "Debug GPU Overdraw" en Developer Options
2. Seleccionar "Show overdraw areas"
3. Navegar a cada vista y tomar screenshot

SCREENSHOT 2.1: LANDING PAGE (Connection View)
----------------------------------------------
VISTA: Pantalla principal con campo "Remote ID"
QUÉ BUSCAR:
- Fondo general: AZUL/VERDE (2x-3x) - esperado
- Campo Remote ID con sombra: ROSA (3x-4x) - hotspot identificado
- Botones con ripple effect: VERDE (3x) - esperado
- Bottom navigation bar: VERDE (2x-3x) - esperado

RESULTADO ESPERADO: Mayoría azul/verde, algunos puntos rosas en widgets elevados

SCREENSHOT 2.2: ACTIVE SESSION VIEW (Normal)
--------------------------------------------
VISTA: Durante sesión remota activa, SIN overlays
QUÉ BUSCAR:
- Área central (remote desktop texture): AZUL (1x) - ÓPTIMO
- Toolbar superior: VERDE/ROSA (2x-3x) - overlay sobre texture
- Input selector inferior: VERDE/ROSA (2x-3x) - overlay sobre texture

RESULTADO ESPERADO: Centro completamente azul (1x), overlays en verde/rosa

SCREENSHOT 2.3: ACTIVE SESSION - DURING RECONNECTION
-----------------------------------------------------
VISTA: Durante reconexión (overlay de "Reconnecting...")
QUÉ BUSCAR:
- Área completa: ROSA/ROJO (4x-5x) - PROBLEMA IDENTIFICADO
- Semi-transparent mask causa overdraw excesivo

RESULTADO ESPERADO: Pantalla completa rosa/roja, confirma bottleneck

SCREENSHOT 2.4: SETTINGS PAGE
-----------------------------
VISTA: Página de configuración (switches, listas)
QUÉ BUSCAR:
- Mayoría del área: AZUL (1x-2x) - MUY EFICIENTE
- Diseño plano, minimal overlapping

RESULTADO ESPERADO: Casi toda la pantalla azul, confirma eficiencia

UBICACIÓN EN REPORTE: Línea 2471-2495 del latex_app_report_final.ltx

================================================================================
3. MEMORY PROFILING (2 screenshots)
================================================================================

HERRAMIENTA:
- Android: Android Studio Memory Profiler
- iOS: Xcode Instruments → Allocations

SCREENSHOT 3.1: MEMORY TIMELINE (10 minutos)
---------------------------------------------
CÓMO CAPTURAR:
1. Iniciar profiler ANTES de lanzar app
2. Ejecutar flujo completo:
   - Launch app (0:00)
   - Connect to remote (0:30)
   - Active session (0:30 - 5:30)
   - Disconnect (5:30)
   - Wait idle (5:30 - 8:00)
3. Capturar timeline completo (0-10 minutos)

QUÉ DEBE MOSTRAR:
- Eje X: Tiempo (0-10 minutos, con timestamps)
- Eje Y: Memory usage en MB (rango 0-300 MB)
- PATRÓN ESPERADO:
  * 0:00 - Cold start: 50-80 MB baseline
  * 0:10 - Cache loading: spike a 70-110 MB
  * 0:30 - Connection: subida a 100-150 MB
  * 0:30-5:30 - Active session: plateau en 140-250 MB
  * 5:30-8:00 - After disconnect: bajada a 50-80 MB (confirma NO LEAK)
- GC EVENTS: Patrón de sierra (sawtooth) cada 1-3 segundos durante sesión
  * Subida rápida (allocation)
  * Bajada brusca (GC libera memoria)
  * Frecuencia: ~20-40 GC events por minuto durante active session

VALIDACIONES:
✓ RAM estimates: 50-80 MB idle, 140-250 MB active
✓ GC frequency: every 1-3 seconds
✓ No memory leaks: memory returns to baseline after disconnect

SCREENSHOT 3.2: HEAP DUMP COMPARISON
------------------------------------
CÓMO CAPTURAR:
1. BEFORE: Tomar heap dump ANTES de iniciar sesión (app en idle)
2. Iniciar sesión remota, mantener 5 minutos
3. AFTER: Tomar heap dump DESPUÉS de sesión
4. IMPORTANTE: Force GC antes del segundo dump
5. Comparar object counts: Before vs After

QUÉ DEBE MOSTRAR:
Tabla de comparación de objetos:

Object Type           | Before (idle) | After (post-GC) | Expected
---------------------|---------------|-----------------|----------
ui.Image             | ~0-5          | ~0-5           | Same (disposed)
Uint8List            | ~100-500      | ~100-500       | Same (released)
TextureRegistry      | 0             | 0-1            | 0 if disconnected
Timer                | ~5-10         | ~5-10          | Same (cancelled)
TextEditingController| ~3-5          | ~3-5           | Same (disposed)

VALIDACIONES:
✓ ui.Image count no aumenta (disposal funciona)
✓ Uint8List count vuelve a baseline (frame buffers liberados)
✓ No zombie timers (count estable)
✓ Widget lifecycle disposal correcto

UBICACIÓN EN REPORTE: Línea 2579-2620 del latex_app_report_final.ltx

================================================================================
4. CPU PROFILING (3 screenshots)
================================================================================

HERRAMIENTA:
- Android: Android Studio CPU Profiler
- iOS: Xcode Instruments → Time Profiler

SCREENSHOT 4.1: COLD START AND CONNECTION (0-8 segundos)
---------------------------------------------------------
ESCENARIO:
- Lanzar app desde cold start
- Ingresar Remote ID
- Conectar a remote computer

QUÉ DEBE MOSTRAR:
- Eje X: Tiempo (0-8 segundos con labels claros)
- Eje Y: CPU % (0-100%)
- PATRÓN ESPERADO:
  * 0-2s: 40-60% CPU (app launch, Flutter init, Dart VM)
  * 2-3s: 20-30% CPU (cache loading, parallel I/O)
  * 3-8s: 30-50% CPU (connection handshake, encryption setup)
- ANOTACIONES: Marcar cada fase en el screenshot

SCREENSHOT 4.2: ACTIVE SESSION (30 segundos)
--------------------------------------------
ESCENARIO:
- Sesión remota activa y estable
- Movimientos de mouse ocasionales
- Capturar 30 segundos continuos

QUÉ DEBE MOSTRAR:
- CPU Timeline: 25-40% baseline, spikes a 50-70% durante heavy graphics
- FLAME GRAPH / CALL STACK (muy importante):
  * Top 5 métodos que consumen CPU
  * DEBE APARECER: decodeImageFromPixels en top 3
  * Verificar: FFI calls (bind.*) y su duración
  * Identificar: ImmutableBuffer.fromUint8List

VALIDACIONES:
✓ CPU baseline 25-40% (confirma estimación)
✓ decodeImageFromPixels es bottleneck principal
✓ Frame decoding consume 10-15% CPU

SCREENSHOT 4.3: FILE TRANSFER (durante transferencia de 100 MB)
----------------------------------------------------------------
ESCENARIO:
- Durante sesión activa
- Transferir archivo de 100 MB desde móvil a PC
- Capturar durante transferencia activa

QUÉ DEBE MOSTRAR:
- CPU: 40-60% baseline durante transfer
- PEAK: 70-85% si compression está habilitada
- ANOTAR: Identificar si spikes son por compression o solo I/O

VALIDACIONES:
✓ CPU durante transfer: 40-60%
✓ Si compression: peak 70-85%

UBICACIÓN EN REPORTE: Línea 3041-3080 del latex_app_report_final.ltx

================================================================================
5. THREAD TIMELINE (1 screenshot)
================================================================================

HERRAMIENTA:
- Android: Android Studio Profiler → CPU → Thread Activity
- iOS: Xcode Instruments → System Trace

CÓMO CAPTURAR:
1. Iniciar profiling
2. Conectar y mantener active session 60 segundos
3. Capturar thread activity timeline

QUÉ DEBE MOSTRAR:

LAYOUT DEL SCREENSHOT:
┌─────────────────────┬──────────────────────────────────────────┐
│ Thread Names (left) │ Activity Timeline (center)               │
├─────────────────────┼──────────────────────────────────────────┤
│ main / UI           │ ▓▓▓░░░▓▓░░▓▓▓░░░ (Dart isolate)        │
│ GPU / Raster        │ ░░▓▓▓░░░▓▓░░░▓▓▓ (Flutter rendering)   │
│ IO Thread           │ ░▓░░░▓░░░░▓░░░░▓ (Disk/network)        │
│ Platform Thread     │ ▓░░░░░▓░░░░░▓░░░ (Native calls)        │
│ Rust/FFI Thread     │ ░░▓░░░░░▓░░░░░▓░ (RustDesk core)       │
│ ... (others)        │ ...                                      │
└─────────────────────┴──────────────────────────────────────────┘

LEYENDA:
- ▓ (Verde/Activo): Thread running
- ░ (Gris): Thread sleeping/waiting
- █ (Rojo): BLOCKING operation (>16ms en main thread = PROBLEMA)

CONTEO DE THREADS:
- Contar total de threads visibles
- ESPERADO durante active session: 12-20 threads
- IDENTIFICAR threads por categoría:
  * 1 Main/UI (Dart isolate)
  * 1 GPU/Raster (Flutter)
  * 1-2 IO threads
  * 1-2 Platform threads
  * 5-10 Rust/FFI threads (video decoding, network)
  * 2-5 System threads

QUÉ BUSCAR / ANALIZAR:
1. Main Thread Blocking:
   - ¿Hay segmentos ROJOS (>16ms) en main thread?
   - Si sí: Identificar qué operación (FFI call, image decode)

2. FFI Call Duration:
   - ¿Cuánto duran las llamadas bind.*?
   - ESPERADO: <16ms (no blocking)
   - PROBLEMA: >16ms causa frame drops

3. Thread Starvation:
   - ¿Hay threads esperando excesivamente?
   - IO thread debería tener actividad durante session

4. Concurrent Execution:
   - Validar que IO operations NO corren en main thread
   - Verificar operaciones en paralelo (main + IO + GPU simultáneo)

VALIDACIONES:
✓ Thread count: 12-20 (confirma estimación)
✓ Main thread: Identificar blocking operations
✓ FFI blocking: Risk level MEDIUM (validar duración)
✓ Image decoding: HIGH risk en main thread

UBICACIÓN EN REPORTE: Línea 2829-2871 del latex_app_report_final.ltx

================================================================================
6. BATTERY / POWER CONSUMPTION (1 screenshot + 1 tabla)
================================================================================

SCREENSHOT 6.1: POWER CONSUMPTION BREAKDOWN
-------------------------------------------

HERRAMIENTA ANDROID:
1. Enable battery stats:
   adb shell dumpsys batterystats --enable full-wake-history
2. Reset stats:
   adb shell dumpsys batterystats --reset
3. Usar app 30 minutos (active remote session)
4. Dump stats:
   adb bugreport > bugreport.zip
5. Upload a Battery Historian: https://bathist.ef.lc/
6. Capturar screenshot del breakdown

HERRAMIENTA iOS:
1. Xcode → Window → Devices and Simulators
2. Seleccionar device → Energy Log
3. Grabar durante active session (30 min)
4. Capturar Energy Gauge

QUÉ DEBE MOSTRAR:
- Power consumption breakdown (mW):
  * CPU: 500-800 mW (ESPERADO)
  * GPU: 400-700 mW (ESPERADO)
  * Network (WiFi): 300-500 mW (ESPERADO)
  * Screen: XXX mW (anotar pero EXCLUIR de total)
  * TOTAL (sin screen): 1500-2500 mW (ESPERADO)

- Battery drain rate:
  * % per hour durante active session
  * Comparar con baseline (app idle)
  * Extrapolate: Estimated hours of continuous use

CÁLCULO ESPERADO:
- Batería: 4000 mAh @ 3.7V = 14.8 Wh
- Consumo: 2W promedio
- Runtime: 14.8 Wh / 2W = ~7.4 hours continuous
- Con breaks: ~10-12 hours mixed use

TABLA 6.2: COMPETITIVE COMPARISON
----------------------------------

PROTOCOLO DE TEST:
- Mismo device (especificar modelo)
- Mismo escenario: 30-min active remote session
- Mismas condiciones: WiFi, screen brightness constante
- Medir para 4 apps: RustDesk, TeamViewer, Chrome Remote Desktop, AnyDesk

TABLA ESPERADA:

App                    | Power (mW) | Battery Drain | Estimated Runtime
                       |            | (%/hour)      | (hours continuous)
-----------------------|------------|---------------|-------------------
RustDesk               | 1500-2500  | ~13-22%       | 7-10 hours
TeamViewer             | 2000-2800  | ~18-25%       | 6-8 hours (higher)
Chrome Remote Desktop  | 1800-2300  | ~15-20%       | 7-9 hours (similar)
AnyDesk                | 1600-2400  | ~14-21%       | 7-9 hours (similar)

VALIDACIONES:
✓ RustDesk power: 1500-2500 mW (confirma estimación)
✓ Competitive: Similar o mejor que alternativas
✓ Battery life: ~7.4 hours confirma cálculo

UBICACIÓN EN REPORTE: Línea 3189-3235 del latex_app_report_final.ltx

================================================================================
RESUMEN DE SCREENSHOTS
================================================================================

TOTAL: 13 screenshots + 1 tabla comparativa

DISTRIBUCIÓN:
[1] GPU Rendering Timeline
[4] Overdraw Analysis (Landing, Session, Reconnection, Settings)
[2] Memory Profiling (Timeline 10-min, Heap dump comparison)
[3] CPU Profiling (Cold start, Active session, File transfer)
[1] Thread Timeline
[1] Battery Profiler
[1] Competitive Comparison Table

TIEMPO ESTIMADO PARA CAPTURA:
- Setup inicial: 30 min (instalar tools, enable developer options)
- GPU profiling: 5 min
- Overdraw screenshots: 10 min
- Memory profiling: 15 min (10-min session + heap dumps)
- CPU profiling: 20 min (3 scenarios)
- Thread timeline: 5 min
- Battery profiling: 45 min (30-min session + processing)
- Competitive comparison: 2 hours (4 apps × 30 min each)
TOTAL: ~3.5 - 4 horas de trabajo

PRIORIDAD DE CAPTURA:
1. HIGH PRIORITY (valida claims principales):
   - Memory Timeline (confirma no leaks)
   - CPU profiling active session (confirma decoding bottleneck)
   - Thread timeline (confirma blocking operations)

2. MEDIUM PRIORITY (valida optimizaciones):
   - GPU rendering timeline (confirma adaptive filtering)
   - Overdraw analysis (confirma layer stack analysis)

3. LOW PRIORITY (nice to have):
   - Battery comparison (competitive positioning)
   - CPU cold start/file transfer (edge cases)

================================================================================
INTEGRACIÓN CON REPORTE
================================================================================

UBICACIÓN EN latex_app_report_final.ltx:

1. GPU profiling: Línea 2373-2388
2. Overdraw: Línea 2471-2495
3. Memory profiling: Línea 2579-2620
4. CPU profiling: Línea 3041-3080
5. Thread timeline: Línea 2829-2871
6. Battery profiling: Línea 3189-3235
7. Validation checklist: Línea 3322-3442

CÓMO AGREGAR SCREENSHOTS AL REPORTE:
1. Guardar screenshots como PNG en carpeta: screenshots/
2. Nombrar archivos:
   - gpu_rendering_timeline.png
   - overdraw_landing.png
   - overdraw_session.png
   - overdraw_reconnection.png
   - overdraw_settings.png
   - memory_timeline.png
   - memory_heapdump.png
   - cpu_coldstart.png
   - cpu_active.png
   - cpu_filetransfer.png
   - thread_timeline.png
   - battery_profiler.png
   - battery_comparison_table.png

3. En LaTeX, agregar en cada sección marcada con [SCREENSHOT NEEDED]:

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{screenshots/gpu_rendering_timeline.png}
\caption{GPU Rendering Timeline durante sesión activa (60 segundos).
         Muestra frame times mayormente <16ms (verde) con picos ocasionales
         durante operaciones de zoom.}
\label{fig:gpu_timeline}
\end{figure}

4. Reemplazar texto "[SCREENSHOT NEEDED: ...]" con la figura LaTeX

5. En resultados, comparar valores reales vs predicciones:
   - "Predicted: 140-250 MB during active session"
   - "Measured: 165 MB average (within predicted range ✓)"

================================================================================
NOTAS IMPORTANTES
================================================================================

1. DEVICE SELECTION:
   - Usar dispositivo REAL (no emulator) para battery/power tests
   - Especificar modelo exacto en reporte
   - Documentar specs: RAM, CPU, Android/iOS version

2. TEST CONDITIONS:
   - WiFi estable (no cellular)
   - Screen brightness fija (50%)
   - Background apps cerradas
   - Battery >50% al iniciar tests

3. REPRODUCIBILIDAD:
   - Documentar steps exactos para cada screenshot
   - Incluir timestamps y durations
   - Remote computer specs (para session tests)
   - Network conditions (latency, bandwidth)

4. VALIDATION APPROACH:
   - Comparar mediciones reales vs predicciones del reporte
   - Si difieren >20%: Investigar y documentar por qué
   - Si concuerdan: Confirma validez del análisis estático

5. SCREENSHOT QUALITY:
   - Resolución mínima: 1920x1080
   - Formato: PNG (mejor que JPG para gráficos)
   - Labels y annotations visibles
   - Include timestamps donde sea posible

================================================================================
FIN DEL DOCUMENTO
================================================================================
